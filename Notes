## Low-level IO
- "open()" system call returns the lowest available descriptor
- descriptors:
-- 0 stdin  -> typically connected to keyboard
-- 1 stdout -> tipically connected to the screen (tty)
-- 2 stderr -> same as stdout

- write() / read() -> low level system calls, it just transafers raw binary data between file and memory
- "read()" -> returns the number os bytes actually readed or 0(end-of-file)
- "close()" -> closes the descriptor, makes it available for re-use. Descriptors are implicitly closed when a process terminates
- Always good practice to close the descriptor, because there is a FINITE limit of how many descriptors a process can open
- Sequential access has a File position pointer, witch points to the begining of the file, unless file is open for append
- File position pointer advances on "read()" call
- File position can be explicitly set with "lseek()"

## Standard library IO
- fopen / fwrite / fread / fclose / fseek / rewind
- Uses "FILE *" as descriptor type, while Low level uses "int"
- Uses User-space buffering that can be a performance improvement, while Low level does not
- Is part of C standard
- It does not dive into kernel every time you call it, it accumulates data into a buffer, and only troubles kernel with it when enough data is available for write.

## Scatter/GAther IO
- Read or write multiple buffers of data in a single call
- Its atomic
- Uses mmap to store arrays of data into memory and memcpy to copy data between them

# File Directory and structure
- Files create inodes when created
- Directory is also an inode with links, where links are a relation between name and an inode number
- "stat()" and "fstat()" reads file attributes, basicaly it reads the inode
- Seems odd, but Linux systems do not stores the creation time of a file
- Use "noatime" when mounting a file system, prevents it from update inode timestamps everytime a file is readed